### 缓存更新策略  
1. **内存淘汰**  
2. **超时剔除**  
3. **主动更新**  
  
**主动更新策略**  
1. Cache Aside Pattern  
- **删除缓存还是更新缓存**
	- 更新缓存可能会产生很多的无效写操作，因为用户可能只查询最后一次更新后的信息
	- 删除缓存，更新数据库时让缓存失效，查询时再更新缓存，这样就可以保证需要查询的时候，获取最新的数据并缓存到redis中  
- **如何保证缓存与数据库操作同时成功或失败**
	- 单体系统，将缓存与数据库操作放在一个事务中。
	- 分布式系统 - 利用TTC等分布式事务方案。
- **先操作缓存还是先操作数据库（线程安全问题）**
	- 先删缓存，再操作数据库
		- **特殊情况**：在并发情况下，如果线程1删除缓存了，还没有更新数据库，此时，线程2查询缓存，未命中，查询数据库，再将数据缓存到redis中，此时redis中的值是旧值，此时线程1更新了数据库，redis和数据库数据不一致。
		- 这种情况很可能发生，因为线程1更新数据库的操作比较慢。
	- 先操作数据库，再删缓存
		- **特殊情况**：线程1查询缓存，未命中，查询数据库，此时，线程2来执行更新数据库操作，并执行删除缓存操作，之后，线程1将刚才查询的旧数据写入了缓存
		- 这种情况发生极少，因为线程1查询过数据库，写入缓存的时间应该极低，线程2不太可能在线程1写入缓存前执行更新数据库等操作。如果发生，还可以使用超时剔除作为兜底方案，也就是为redis中的数据添加上过期时间。
		- ==**所以选择先操作数据库，再删缓存**==
2. Read/Write Through Pattern  
3. Write Behind Caching Pattern
#### 高一致性需求：主动更新，并以超时剔除作为兜底
- 读操作
	- 缓存命中则直接返回
	- 未命中查询数据库，并写入缓存，设置过期时间
- 写操作
	- 先写数据库，再删缓存
	- 确保数据库与缓存操作的原子性