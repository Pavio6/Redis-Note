### 缓存更新策略  
1. **内存淘汰** - Redis自带的内存淘汰机制
2. **超时剔除** - 利用expire命令给数据设置过期时间
3. **主动更新**  
  
**主动更新策略**  
1. Cache Aside   
- **删除缓存还是更新缓存**
	- 更新缓存可能会产生很多的无效写操作，因为用户可能只查询最后一次更新后的信息
	- 删除缓存，更新数据库时让缓存失效，查询时再更新缓存，这样就可以保证需要查询的时候，获取最新的数据并缓存到redis中  
- **如何保证缓存与数据库操作同时成功或失败**
	- 单体系统，将缓存与数据库操作放在一个事务中。
	- 分布式系统 - 利用TTC等分布式事务方案。
- **先操作缓存还是先操作数据库（线程安全问题）**
	- 先删缓存，再操作数据库
		- **特殊情况**：在并发情况下，如果线程1删除缓存了，还没有更新数据库，此时，线程2查询缓存，未命中，查询数据库，再将数据缓存到redis中，此时redis中的值是旧值，此时线程1更新了数据库，redis和数据库数据不一致。
		- 这种情况很可能发生，因为线程1更新数据库的操作比较慢。
	- 先操作数据库，再删缓存
		- **特殊情况**：线程1查询缓存，未命中，查询数据库，此时，线程2来执行更新数据库操作，并执行删除缓存操作，之后，线程1将刚才查询的旧数据写入了缓存
		- 这种情况发生极少，因为线程1查询过数据库，写入缓存的时间应该极低，线程2不太可能在线程1写入缓存前执行更新数据库等操作。如果发生，还可以使用超时剔除作为兜底方案，也就是为redis中的数据添加上过期时间。
		- ==**所以选择先操作数据库，再删缓存**==
1. Read/Write Through   
2. Write Behind Caching 

#### 低一致性需求：内存淘汰或过期淘汰
#### 高一致性需求：主动更新，并以超时剔除作为兜底
- 读操作
	- 缓存命中则直接返回
	- 未命中查询数据库，并写入缓存，设置过期时间
- 写操作
	- 先写数据库，再删缓存
	- 确保数据库与缓存操作的原子性

### 缓存穿透
**指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库，如果不断发起这样的请求，会给数据库带来巨大压力**

#### 解决方案
1. 缓存null值
2. 使用布隆过滤器
3. 增强id的复杂度，避免被猜测id的规律，并做好数据的基础格式校验
4. 加强用户权限校验

### 缓存雪崩
**指同一时段大量的缓存Key同时失效或Redis服务宕机，导致大量请求到达数据库，带来巨大压力**

#### 解决方案
1. 给不同的key的TTL添加随机值
2. 利用Redis集群提高服务的可用性
3. 给缓存业务添加降级限流策略
4. 给业务添加多级缓存

### 缓存击穿（热点Key）
**指一个被高并发访问并且缓存重建业务较复杂的key突然失效，无数的请求访问会瞬间给数据库带来巨大的冲击**

#### 解决方案
1. 互斥锁
	- **核心流程**：先查缓存 → 未命中尝试抢锁 → 锁失败短暂休眠重试 → 锁成功后 double-check 缓存 → 仍未命中则查 DB 写缓存 → 释放锁返回。
	 - **缺点** - 线程需要等待，性能受影响，可能产生死锁
2. 逻辑过期
	- **核心流程**：查缓存→未命中直接返回空→命中后看 ExpireTime：
		- 未过期：直接返回数据
		- 已过期：尝试抢锁；抢锁失败返回旧数据；抢锁成功则起 goroutine 回源+重建缓存（并释放锁）。
	- **优点** - 线程无需等待，性能较好
	- **缺点** - 不保证一致性，有额外内存消耗

##### 使用建议
- **强一致/强隔离场景优先互斥锁方案。**
- **读多写少、可接受短暂陈旧的热点 Key 可用逻辑过期。**








