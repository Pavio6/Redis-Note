
**Redis 集群模式**（Redis Cluster）是 Redis 为了解决 **单个实例的扩展性** 和 **高可用性** 问题而提出的一种分布式部署方式。Redis 集群通过 ==**分片**== 和 ==**主从复制**== 的方式，将数据分布到多个节点上，并且提供了 **自动故障转移**、**高可用性** 和 **自动数据重分布** 的功能，能够有效处理大量数据和高并发的请求。

# Redis分片集群

**主从和哨兵可以解决高可用、高并发读的问题，但是仍有两个问题没有解决**
- 海量数据存储
- 高并发写

**使用分片集群可用解决上述问题**
- 集群中有多个master，每个master保存不同的数据
- 每个master都可以有多个slave节点
- master之间通过ping监测彼此健康状态
- 客户端请求可以访问集群任意节点，最终都会被转发到正确节点

## 哈希槽（Hash Slots）

- **哈希槽** 是 Redis 集群分片的核心概念。Redis 集群将所有的 **键（key）** 映射到 **16384 个哈希槽** 中。每个节点负责一部分哈希槽，因此每个节点只处理自己负责的哈希槽范围内的数据。
- 当 Redis 客户端存储一个键时，Redis 会通过哈希函数（如 CRC16）计算出该键对应的 **哈希槽编号**，然后将该数据存储到负责这个哈希槽的节点上。
- **16384 个哈希槽** 是固定的，任何 Redis 集群都使用这 16384 个槽来分配数据。

### 哈希标签（Hash Tag）
为了实现特定数据的 **分布式存储** 和 **数据的粘性（即同一组数据尽量存储在同一个节点上）**，Redis 提供了 **哈希标签（hash tag）** 的机制。哈希标签允许你 **定制** 键名的“有效部分”，从而影响数据的分片。

**哈希标签的定义和使用**
哈希标签是键名中的一部分，它通过将键名中的 **一部分字符串** 提取出来，作为哈希计算的依据。

哈希标签的格式是：
- 将键名中的一对 {} 花括号内的内容作为哈希计算的依据。
**例如：**
- user:123{name}
- user:234{name}
这两个key会被映射到相同的哈希槽

## 集群伸缩

### 1. 核心概念：基于槽位的重新分配

Redis 集群的伸缩本质上是 **哈希槽（Hash Slots）** 在节点之间的移动。

- **总量恒定**：无论集群有多少节点，哈希槽总量永远是 $16384$ 个。
    
- **计算公式**：$\text{slot} = \text{CRC16}(\text{key}) \pmod{16384}$。
    
- **伸缩本质**：扩容是把部分槽位从旧节点挪到新节点；收缩是把下线节点的槽位全部挪给其他节点。
    

---

### 2. 扩容流程（Scale-out）

当集群需要更多内存或更高并发能力时，执行以下四个阶段：

##### 第一阶段：上线新节点

在 Docker 或物理机上启动新的 Redis 实例（配置 `cluster-enabled yes`）。此时新节点是孤立的，不属于任何集群。

##### 第二阶段：加入集群 (`add-node`)

使用 `redis-cli --cluster add-node` 命令。

- **新节点身份**：默认作为 Master 加入。
    
- **状态**：此时它已进入集群名单，但负责的槽位数为 $0$，因此不处理任何读写请求。
    

##### 第三阶段：重新分片 (`Resharding`) —— **核心步骤**

这是搬运数据的过程。你需要决定从哪些旧 Master 中抽取多少槽位给新 Master。

1. **目标节点**：指定新 Master 的 ID。
    
2. **源节点**：通常选择 `all`，即从所有旧 Master 手中按比例各拿一点，保证集群依然平衡。
    
3. **数据迁移**：Redis 会自动搜索属于这些槽位的 Key，并将其物理搬迁到新节点。
    

##### 第四阶段：配置从节点

为了保证高可用，必须为新 Master 增加至少一个 Slave。

- 命令：`add-node --cluster-slave`。
    

---

### 3. 收缩流程（Scale-in）

收缩操作必须遵循 **“先挪走，再踢出”** 的原则，直接关机导致数据丢失。

##### 第一阶段：迁移槽位

将准备下线的 Master 所负责的所有槽位，平摊移动到剩下的 Master 节点上。

- **注意**：如果该节点有 Slave，建议先迁移 Master 槽位，再处理 Slave。
    

##### 第二阶段：忘记节点 (`del-node`)

使用 `del-node` 命令。

1. 该命令会向集群中所有节点发送 `CLUSTER FORGET` 指令。
    
2. 在 60 秒内，所有节点会将该 ID 移出“白名单”，不再与其通信。
    

##### 第三阶段：关机

只有当节点手中槽位为 $0$ 且已被集群移除后，才能安全停止容器。

---

### 4. 底层迁移机制：ASK 重定向

在伸缩过程中，数据搬迁需要时间。如果此时客户端访问正在搬家的 Key，会发生什么？

Redis 使用 **ASK 重定向** 机制解决这个问题：

1. **客户端请求**：访问正在迁移的 Slot X。
    
2. **源节点响应**：如果 Key 还在，直接处理；如果 Key 已搬走，回复 `ASKing` 错误。
    
3. **转向新节点**：客户端收到 `ASKing` 后，临时去新节点找这个 Key。
    
4. **迁移完成**：搬迁结束后，源节点会给客户端回 `MOVED`，让客户端以后永久更新本地缓存，直接找新节点。

---

### 5. 伸缩的最佳实践

### A. 保持集群对称性

- **建议**：扩容时，Master 和 Slave 最好成对增加（例如从 3主3从 变为 4主4从）。
    

### B. 迁移粒度

- **风险**：迁移超大 Key（如几百万个元素的 Hash）会导致节点阻塞。
    
- **对策**：在业务低峰期执行，并监控 `slowlog`。
    

### C. 故障转移优先级

- 在伸缩期间，如果发生 Master 宕机，故障转移依然可以进行，但尽量避免在迁移高峰期手动触发 `failover`。
    

---

### 6. 常用命令清单

| **操作类型**  | **命令示例**                                                                         |
| --------- | -------------------------------------------------------------------------------- |
| **添加主节点** | `redis-cli --cluster add-node <new_ip>:<port> <exist_ip>:<port>`                 |
| **添加从节点** | `redis-cli --cluster add-node <new_ip>:<port> <exist_ip>:<port> --cluster-slave` |
| **执行分片**  | `redis-cli --cluster reshard <any_node_ip>:<port>`                               |
| **删除节点**  | `redis-cli --cluster del-node <any_node_ip>:<port> <node_id>`                    |
| **检查状态**  | `redis-cli --cluster check <any_node_ip>:<port>`                                 |

---

## 故障转移
### 自动故障转移 (Automatic Failover)


**自动故障转移是 Redis 集群的默认行为，系统会自动处理主节点故障，并尽可能减少停机时间。**

#### **工作原理**

- **节点监控**：集群中的每个节点都会定期向其他节点发送心跳包，检测其他节点是否正常。如果一个主节点在一定时间内没有响应其他节点的心跳，它将被标记为 **故障**。
    
- **故障检测**：当一个主节点无法联系到其他节点时，集群会通过 **投票机制** 来确认主节点的故障状态。通常，至少需要一部分集群节点确认主节点失效才能开始故障转移。
    
- **选举从节点**：当一个主节点故障时，集群会选择一个健康的从节点来接管故障主节点的工作。选举过程会选择数据同步状态最好的从节点进行升级。
    
- **新主节点接管**：选举出来的新主节点开始接管原主节点的工作，包括处理客户端请求、管理哈希槽和复制数据等。
### 手动故障转移 (Manual Failover)

  

手动故障转移是指集群管理员在发生主节点故障时手动干预，通过命令或工具来触发故障转移操作。手动故障转移通常在某些特殊场景下使用，比如需要人工确认节点的健康状态，或者想要控制故障转移的具体过程。

#### **工作原理**

手动故障转移要求运维人员在主节点出现故障时执行命令或通过管理工具手动触发节点切换。通常的操作步骤如下：

1. **检测故障节点**：通过 redis-cli 或集群管理工具检测主节点的故障状态，确认是否真的发生了故障。
    
2. **手动触发故障转移**：使用 Redis 的 CLUSTER FAILOVER 命令手动触发故障转移。这个命令会让指定的从节点升级为主节点，并开始处理请求。

```bash
redis-cli -h <node_ip> -p <node_port> CLUSTER FAILOVER
```

